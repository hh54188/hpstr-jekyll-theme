# 深入理解 Webpack 打包分块

## 前言

随着前端代码需要处理的业务越来越繁重，我们不得不面临的一个问题是前端的代码体积也变得越来越庞大。这造成无论是在调式还是在上线时都需要花长时间等待编译完成，并且用户也不得不花额外的时间和贷款下载越来越大体积的脚本文件。

然而仔细想想这完全是可以避免的：在开发时难道一行代码的修改也要重新打包整个脚本再次上线？用户只是稍浏览页面也需要将整个站点的脚本全部下载下来？所以趋势必然是按需的、有策略性的将代码拆分和提供给用户。最近流行的微前端某种意义上来说也是遵循了这样的原则（但也并不是完全基于这样的原因）

幸运的是，我们目前手头上的工具已经完全赋予我们实现以上需求的能力。例如 Webpack 允许我们在打包时将脚本分块；利用浏览器缓存我们能够有的放矢的加载脚本。

在探寻最佳实践的过程中，最让我疑惑的不是我们能不能做，而是我们应该如何做：我们因该采取什么样的特征拆分脚本？我们应该使用什么样的缓存策略？使用懒加载和分块是否有异曲同工之妙？拆分之后究竟能带来多大的性能提升？最重要的是，在面多诸多的方案和工具以及不确定的因素时，我们应该如何开始？这篇文章就是对以上问题的梳理和回答。文章的内容大体分为两个方面，一方面在思路制定模块分离的策略，另一方面从技术上对方案进行落地。

本文的部分内容翻译自 [The 100% correct way to split your chunks with Webpack](https://hackernoon.com/the-100-correct-way-to-split-your-chunks-with-webpack-f8a9df5b7758)。 这篇文章很好的循序渐进的引导开发者步步为营的对代码进行拆分优化，所以它的译文是作为本文的线索存在。同时在它的基础上，我会对某些知识点做纵向扩展，对方案进行落地。

以下开始正文

---

根据 [Webpack 术语表](https://webpack.js.org/glossary/)，存在两类文件的分离。这些名词听起来是可以互换的，但实际上不行：

- 打包分离 (Bundle splitting)：为了更好的缓存创建更多、更小的文件（但仍然以每一个文件一个请求的方式进行加载）
- 代码分离 (Code splitting)：动态加载代码，所以用户只需要下载当前他正在浏览的站点的这部分代码

第二种策略听起来更吸引人是不是？事实上许多的文章也假定认为这才是唯一值得将 JavaScript 文件进行小文件拆分的场景。

但是我在这里告诉你第一种策略对许多的站点来说才更有价值，并且应该是你首先为页面做的事

让我们来深入这件事

## Bundle VS Chunk VS Module

在正式开始编码之前，我们还是要明确一些概念。例如我们贯穿全文的“块”(chunk) ，以及它和我们常常提到的“包”(bundle)以及“模块”(module) 到底有什么区别。

遗憾的事情是即使在查阅了很多资料之后，我仍然没法得到一个确切的标准答案，所以这里我选择我个人比较认可的定义在这里做一个分享，重要的还是希望能起到统一口径的作用

首先对于“模块”(module)的概念相信大家都没有异议，它指的就是我们在编码过程中有意识的封装和组织起来的代码片段。狭义上我们首先联想到的是碎片化的 React 组件，或者是 CommonJS 模块又或者是 ES6 模块，但是对 Webpack 和 Loader 而言，广义上的模块还包括样式和图片，甚至说是不同类型的文件

而“包”(bundle) 就是把相关代码都打包进入的单个文件。如果你不想把所有的代码都放入一个包中，你可以把它们划分为多个包，也就是“块”(chunk) 中。从这个角度上看，一个块就是一个包。它是对代码再一层的组织和封装。

但如果要仔细的深究，**Chunk**是 Webpack 用于管理打包流程中的技术术语，甚至能划分为不同类型的 chunk。我想我们不用从这个角度理解。只需要记住上一段的定义即可


## 打包分离 (Bundle splitting)

打包分离背后的思想非常简单。如果你有一个体积巨大的文件，并且只改了一行代码，用户仍然需要重新下载整个文件。但是如果你把它分为了两个文件，那么用户只需要下载那个被修改的文件，而浏览器则可以从缓存中加载另一个文件。

值得注意的是因为打包分离与缓存相关，所以对站点的首次访问者来说没有区别

（我认为太多的性能讨论都是关于站点的首次访问。或许部分原因是因为“第一映像”很重要，另一部分因为这部分性能测量起来简单和讨巧）

当谈论到频繁访问者时，量化性能提升会稍有棘手，但是我们必须量化！

这将需要一张表格，所以我们将每一种场景与每一种策略的组合结果都记录下来

我们假设一个场景：

- Alice 连续 10 周每周访问站点一次
- 我们每周更新站点一次
- 我们每周更新“产品列表”页面
- 我们也有一个“产品详情”页面，但是目前不需要对它进行更新
- 在第 5 周的时我们给站点新增了一个 npm 包
- 在第 8 周时我们更新了现有的一个 npm 包

当然包括我在内的部分人希望场景尽可能的逼真。但其实无关紧要，我们随后会解释为什么。

## 性能基线

假设我们的 JavaScript 打包后的总体积为 400KB, 将它命名为 `main.js`，然后以单文件的形式加载它

我们有一个类似如下的 Webpack 配置（我已经移除了无关的配置项）：

```javascript
const path = require('path');

module.exports = {
  entry: path.resolve(__dirname, 'src/index.js'),
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js',
  },
};
```
当只有单个入口时，Webpack 会自动把结果命名为`main.js`

（对那些刚接触缓知识的人我解释一下：每当我我提及`main.js`的时候，我实际上是在说类似于`main.xMePWxHo.js`这种包含一堆带有文件内容哈希字符串的东西。这意味着当你应用代码发生更改时新的文件名会生成，这样就能迫使浏览器下载新的文件）

所以当每周我向站点发布新的变更时，包的`contenthash`就会发生更改。所以每周 Alice 访问我们站点时不得不下载一个全新的 400KB 大小的文件

![](./images/webpack-chunk-split/001.png)

连续十周**也就是 4.12MB**

我们能做的更好

### 哈希（hash）与性能

不知道你是否真的理解上面的表述，或者不知道会不会产生额外的疑问。有几点需要在这里澄清：

1. 为什么带哈希串的文件名会对浏览器缓存产生影响？
2. 为什么文件名里的哈希后缀是`contenthash`？如果把`contenthash`替换成`hash`或者`chunkhash`有什么影响？

为了每次访问时不让浏览器都重新下载同一个文件，我们通常会把这个文件返回的 HTTP 头中的`Cache-Control`设置为`max-age=31536000`，也就是一年（秒数的）时间。这样以来，在一年之内用户访问这个文件时，都不会再次向服务器发送请求而是直接从缓存中读取，直到或者手动清除了缓存。

如果我中途修改了文件内容必须让用户重新下载怎么办？修改文件名就好了，不同的文件（名）对应不同的缓存策略。而一个哈希字符串就是根据文件内容产生的“签名”，每当文件内容发生更改时，哈希串也就发生了更改，文件名也就随之更改。这样一来，旧版本文件的缓存策略就会失效，浏览器就会重新加载新版本的该文件。当然这只是其中一种最基础的缓存策略，更复杂的场景请参考我之前的一篇文章：[设计一个无懈可击的浏览器缓存方案：关于思路，细节，ServiceWorker，以及HTTP/2](https://zhuanlan.zhihu.com/p/28113197)

所以在 Webpack 中配置的 `filename: [name]:[contenthash].js` 就是为了每次发布时自动生成新的文件名。

然而如果你对 Webpack 稍有了解的话，你应该知道 Webpack 还提供了另外两种哈希算法供开发者使用：`hash`和`chunkhash`。那么为什么不使用它们而是使用`contenthash`？这要从它们的区别说起。

原则上来说，它们是为不同目的服务的，但在实际操作中，也可以交替使用

- [hash]
- [chunkhash]
- [contenthash]









## 参考资料

- [What are module, chunk and bundle in webpack?](https://stackoverflow.com/questions/42523436/what-are-module-chunk-and-bundle-in-webpack)
- [Concepts - Bundle vs Chunk](https://github.com/webpack/webpack.js.org/issues/970)
- [SurviveJS: Glossary](https://survivejs.com/webpack/appendices/glossary/)