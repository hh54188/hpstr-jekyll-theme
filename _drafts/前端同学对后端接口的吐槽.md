# 前端同学对后端接口的吐槽
约定
唯一健不一致
无论什么都返回200
忽略http code 
结构不一致(缺少契约测试？
Design for today
Design for onething 
便于试用和测试
Mediation Layer 用于接口更新
API 文档和爆炸
不要拘泥于 Web API
反馈让接口更好 ssud 
Debug 

参考其他公司的接口是怎么做的

数据的加工和二次转化

## 前言
去年的某个时候就想写一篇关于接口的吐槽，当时后端提出了接口方案对于我来说调用起来非常难受，但又说不上为什么，没有论点论据所以也就作罢。最近因为写全栈的缘故，团队内部也遇到了一些关于接口设计的问题，于是开始思考实现接口的最佳实践是什么。在参考了许多资料之后，逐渐对这个问题有了一些自己的理解。同时回想起过去的经验，终于恍然大悟自己当时的痛点在哪里。

既然是吐槽，那么请原谅我接下来态度的不友善

## 谁应该主导接口的设计
或者更直白一些，应该接口的消费方还是接口的提供方来决定接口的设计？

当然是接口的消费方 

「接口」最吊诡的地方在于提供方大费周章把它实现了，但它自己却（几乎）重来都不使用。于是这极易陷入一种自嗨的境地，因为他更本不知道接口的好坏。就好比一个从来不尝自己做出来的菜的厨子，你指望他的菜能好到哪里去，他的厨艺能好到哪里去。上面隐含的前提是（我认为）接口是有绝对的好坏之分的，坏的接口消费者调用难受，提供者维护难受，还导致产品行为别扭体验变差。自己体会，不解释

然而接口的好坏与谁来主导设计有什么关系？因为坏接口产生的原因之一就是只站在开发者的角度解决问题。接下来举个人经历的一个足以说明问题的极端例子

---

### 例子一

某次需要实现用户创建仪表盘页面的功能（如果你对仪表盘页面感到陌生的话，可以想象它是一张集中了不同图表的页面，比如柱状图、折线图、饼图等等。用户可以添加自己想要的图表到页面中，并且手动调整它们的尺寸和位置。仪表盘通常用于总览某个产品或者服务的运行状态）。后端同学的接口初步设计是，当用户填写完基本信息、添加完图表、点击创建按钮之后，我需要连续调用两次接口才能完成一次仪表盘的创建：

	1. 使用用户填写的基本信息以及图表的尺寸和位置创建一个空的仪表盘
	2. 再向仪表盘中填充图表的具体信息，比如图表类型，使用的维度和指标等

---

你可以很明显看出他完全是按照自己后端的存储结构在设计接口，不仅是存储结构，甚至存储过程都一览无余。想象一种极端的情况，那不如你只开发一些更新数据库表的接口得了，前端自己把通过接口把数据插入库中

面对这类底层性质的接口，消费者在集成这种接口时需要考虑接口的调用步骤以及理解背后的原理，同时如果后端的底层结构一旦发生更改，接口很有可能也需要发生更改，同时前端的调用代码也需要发生更改。

后端研发可能会辩解说：我后端用了微服务啊，不同类型的数据存储在不同的服务上，所以你需要和不同的服务通信才能实现完整的存储。他们始终没有明白的事情是，你后端的实现导致了接口的碎片化，那是你的问题，而不应该把这部分负担转移到前端的开发者上，这样必然导致了前端的一些 trade off，也其实是间接转移到了用户身上。不要欺负我不懂后端，至少我了解加一层类似于 BFF 的 Orchestration Layer 就能解决这个问题

Netflix 的工程师 Daniel Jacobson 在他的文章 [The future of API design: The orchestration layer](https://thenextweb.com/dd/2013/12/17/future-api-design-orchestration-layer/) 中指出， API 无非是要面对两类受众：

	1. LSUD: Large set of unknown developers
	2. SSKD: Small set of known developers 

随着产品服务化的趋势，很有可能需要像 AWS 或者 Github 那样对公共开发者即 LSUD 暴露接口。且不说上面例子中的接口会不会被唾沫星子淹死，如此明显的暴露内部服务的细节是非常危险的事情。

所以在设计接口时，应该让消费者来主导。如果消费者没能给出很好的建议，那么至少提供者在设计时也应该站在消费者的立场上来思考问题。又或者，至少想一想如果你自己会乐意使用用你自己设计出来的接口吗？

使用后端思维设计接口不仅体现在 URI 的设计上，还有可能体现在请求参数和返回体结构上，我们用一个例子结束这个小节

---

### 例子二

假设现在需要一个请求批量文章的接口，接口同时返回多篇文章的内容，包括这些文章的内容，作者信息，评论信息等等。

理想情况下，我们期望返回的数据是以文章为单位的，比如

```javascript
articles: [
	{
  		id: ,
        author: {},
        comments: []
	},
    {
    	id:
        author: {},
        comments: []
    }
]
```

However, 后端的返回结果可能是以实体为单位：

```javascript
{
    articles: [],
    authors: [],
    comments: []
}
```

---

comments 里包含不同文章的 comment，我必须通过类似于 articleId 的字段对它们执行 group by 操作才能分离出属于不同文章的评论。最终手动的拼接成前端代码需要的 articles 数据结构

很明显这又是按照后端库表关系返回的结果，严格来说这并不算是 anti-pattern，在 redux 中也鼓励将数据 normalize。**但如果前端用不到原始数据，请不要返回原始数据**。又例如我需要在页面上展示一个百分比格式的数据，除非用户同时想看到其他的数据格式，例如千分位、小数或者是精确度的需求，否则就直接返回给我百分比的字符串就好了，不要返回给我原始的浮点数据。

**前端对数据的二次加工还会给问题排查带来干扰**，如果任何数据都需要前端进行二次加工，那么所以问题的排查都必须从前端发起，前端确认无误后再进入后端排查流程，这始终会占用两个端的人力，并且 delay 了排查的进度

## 关于 meta 信息

---

### 例子三：

后端接口在返回时通常会带上 meta 信息，meta 信息通常包含接口的状态以及如果失败时的失败原因，便于调试。后端提供的接口的 meta 信息的数据结构如下：

```javascript
{
    meta: {
      code: 0,
      error: null,
      host: "127.0.0.1"
    },
   	result: []
}
```

---

在我看来，以上数据结构有两个问题

### meta 信息包含独立的状态信息

在包含状态码的 meta 信息接口设计中，包含一条默认的隐藏逻辑是：接口返回的 http status code 一定是 200，数据是否真的获取成功需要通过 meta 里的自定状态码 code 进行判断（换句话说，上面你看到的接口实际上是“接口的接口”）。最终在前端的代码中也不需要通过 http code 判断返回是否正常，只需要判断接口里返回的`meta.code`即可

**但是谁给你们的自信保证后端接口一定是不会挂的？！**无论后端如何保证接口的坚固，前端仍然需要首先判断 http code 是否为 200，再判断`meta.code`是否与预期的符合一致。这和信任无关，和我程序的健壮有关。

既然无论如何都要对接口判断两次，那为什么不将`meta.code`与 http code 合二为一？更何况我还需要再本地维护一份自定义 code 的枚举值，还需要和后端保证同步。这就涉及到下一个问题了：

### meta 信息的存放位置

我们需要 meta 信息没有错，但是我们没有那么需要 meta 信息。这体现在几点：

1. 我们真的需要一个平行于返回结果的字段展示 meta 信息吗？
2. 每一次请求我们都需要 meta 信息吗？
3. meta 信息一定要在 meta 字段里吗？

以请求失败的错误信息为例，错误信息只会出现在接口非正常返回的情况下，但我们应该始终在返回体中用一个字段为它预留位置吗？










