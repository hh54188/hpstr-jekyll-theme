在我刚开始学习React.js时，我的疑问和你是一样的。比如对于组件化最困惑的事情是，我们谈了这么多年的表现与逻辑分离，谈了这么多年的SOC(separation of concerns)，怎么又回到了原点？但是当逐渐阅读到更多的材料，了解到Facebook自己谈论关于它诞生的原因，发现React.js还是有可取之处的。

关于你的疑问的答案，简而言之就是，React确实拥有它的优势，但不适合于所有的业务场景。

当谈论React.js时，有必要从两个方面剖析：

1. 组件化：首先要明确的是它只是一个用于**视图层**的类库，你能把它当作模板引擎来用(**但它并不能算是模板引擎**)，输出html，定义组件，在服务端渲染。但是你没法仅用React.js类库就搭建一个完整的前端SPA(Single Page Application)。之所以要强调这么一点是因为很多人会拿React.js与Angular做比较，这是不公平的，因为angular的定位是一个框架(framework)。angular自带模板引擎、路由引擎、有健全的数据双向绑定机制、内置Ajax请求功能、还能够定义Model等。而React.js类库只能用于定义视图组件。

2. Flux架构：flux是一种架构思想，它是随着React.js而诞生的。但正如上一段所说，React.js仅依靠自己没法成型一个框架，基于React.js的flux框架要么是手动补全了框架中其他角色的代码，要么引入了其他的第三方类库。flux架构也并非是React.js的专利，市面上已经有非常多的独立于React.js的开源框架供使用。

我们将分别谈React.js这两面的起源和优劣。本文较长，请耐心阅读:)

另外本文的flux架构部分摘自我的前端专栏[前端漫游指南](https://zhuanlan.zhihu.com/front-end)中的文章[写给前端看的架构文章(1)：MVC VS Flux](https://zhuanlan.zhihu.com/p/21324696?refer=front-end)

## 组件化

首先用一段简单的代码演示React.js是如何定义一个组件的，为不了解React.js的同学做一些普及工作：

```
var HelloUser = React.createClass({
  	getInitialState: function(){
    	return {
      		username: 'liyi'
    	}
  	},
  	handleChange: function(e){
    	this.setState({
      		username: e.target.value
    	});
  	},
  	render: function(){
    	return (
      		<div>
        		<span>Hello {this.state.username}</span>
        		Change Name: <input type="text" value={this.state.username} onChange={this.handleChange} />
      		</div>
    	)
  	}
});
```
在组件中，我们在`render`函数中定义了输出的html，还定义了输出DOM上`change`事件的回调函数`handleChange`，同时还在`getInitialState`函数中定义了组件的初始化状态，即需要展示的数据值`username`。

所以你看到，在组件中同时有视图(`render`)、行为(`hadnleChange`)、数据(`getInitialState`)。此时你应该更能体会本文开头的那个疑惑：

>我们谈了这么多年的表现与逻辑分离，谈了这么多年的SOC(separation of concerns)，怎么又回到了原点？

作为对比，我们不妨回过头看一看传统的前端代码功能开发是什么样子的。假设我们要开发一个功能，在页面加载时请求用户信息并且展现出来。那么你的HTML代码和Javascript代码可以是分别如下所示编写：

index.html:

```
<header>
	<div class="login">
		<span class="username">Please Login</span>
	</div>
</header>
<script type="text/javascript" src="./login.js"></script>
```

login.js:

```
$.get('/userInfo', options, function loginSuccess(username) {
	$('.username').text(username);
})
```
在实际开发中，html代码可能还会背抽象为一个html碎片或者模板，比如叫做`login-template.html`。因为登陆模块通常会被多个页面公用。

你觉得`login-template.html`和`login.js`算是一种好的表现与逻辑的分离方式吗？我觉得不尽然。

我们现在做的，更准确的来说叫做**技术上的分离**。仔细想来，无论你是在开发`login-template.html`还是`login.js`时，你都不得不引用对方来进行调试和开发。这样可能会产生以下的问题：

1. 在没有`login-template.html`的情况下`login.js`无法验证登陆结果（功能是否正常）
2. 当`login-template.html`中`username`名称发生更改时，`login.js`也需要对应做修改
3. 假设有多个脚本都涉及操作`.username`时，调试`login.js`就成了大问题，我们需要暂停其他对`.username`操作的脚本以进行变量控制。
4. 假设有多个脚本都涉及操作`.username`时，而`.username`的展现行为都非你所愿时，你一时半会都无法排查不知道是哪个脚本的问题。

“登陆”这个模块，无论被哪个子页面复用，这两个文件也都是一定同时被引用的。所以我们现在做的，说白了只是文件上的分离。

既然它们形影不离，为什么不干脆把他们合并，不，更准确的说是封装在一起？我想这就是“组件化”的意义。

**我们在使用React.js定义一个组件时，它的表现、行为、状态同时被定义在同一个React.js模块中，因为正如上面的代码所示，大部分脚本功能在工作时，表现和行为需要知道对方的细节，需要频繁的和对方发生交互，这样的封装更像是一种“成全”。虽然说组件内部的细节如此丰富，但对于外部调用者来说它们都是透明的，没有暴露也无法被修改，调用者只能在使用时赋予它们适合的状态让它们以自己的方式工作。**

称不上完美，但组件也大致解决了上面所说的传统方法可能会产生的问题，例如调试（我们能很方便的找到DOM操作的来源），例如维护修改（一方面JSX语法带来便利，另一方面组件这种紧密组织的方式使得阅读代码时更加一目了然），例如单元测试。总而言之，从最近前端诞生的框架和技术也能看出，组件化也是一种趋势。

如果说上面对美好蓝图的描绘更偏向理论的话，那么接下来说的关于React.js存在的问题则会显得更现实。

首先你要对React.js有一个映像，这个映像是它是一个很“重”的东西。重不单单是指引用类库文件体积大小（虽然它的文件体积也不算小[React v15.1.0](https://cdnjs.cloudflare.com/ajax/libs/react/15.1.0/react.min.js)gzip压缩后43.2kb，相比[AngularJS v1.5.6](https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.5.6/angular.min.js) gzip压缩后55.4kb、[jQuery v2.2.4](https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js)gzip压缩后体积29.7kb），而是一旦决定使用React.js开发，你很大可能需要React.js周边的一系列配套设施类库，俗称React.js全家桶：1. 比如你需要webpack对项目资源进行打包（或者Browserify+Gulp）；2.而在使用webpack的过程中，如果你的React.js组件使用了JSX语法，或者你需要向下兼容浏览器，你需要在webpack里加载babeljs插件；3.此外你还可能需要`react-dom`和`react-dom/server`。即使你看不懂上面我在说什么，你也会觉得看上去很麻烦的样子。当你完成了这些工作之后，还需要给团队配备一样的环境，让他们来学习React.js开发，这才是最致命的。

其次React.js并非适用于所有场景，不是说不允许用，而是使用了反而会让开发效率更低维护成本更高。组件化最重要的一点是组件可以被复用，更准确的说是**需要**被复用，这适用于站点级别的前端开发，因为站点上的控件大多数需要保持功能和风格一致。例如最简单的登陆模块，无论是首页还在频道页都需要使用到，并且要求展开后样式一致，功能一致。这就要求抽象为能被复用的组件；又例如facebook上每一条好友的动态都有相同的点赞和评论功能，这些也都适用于复用。

难道还有非站点级别的开发？有，我现在的工作就是，我需要根据PM的需求开发不同的广告样式。不同的产品经理提出不同功能类型的广告样式，不同类型的广告样式又由不同的设计同学具体到落实的设计稿上，这些广告样式的交互，尺寸，排版都大相径庭，没有办法抽象。我引入一个React至少需要43kb，使用原生的Javascript开发的html和脚本一共才不到10kb，这种情况下使用React很明显是得不偿失的。

另外，React.js更适用于富交互型的前端应用（和flux更配），例如有数据状态的变化以及需要对视图进行更新。

## Flux架构

这篇段落的目的就是让你读懂flux架构，我们会直接把flux与mvc比较，来彰显它的优劣。flux架构并非新事物，如果你拥有后端开发背景的话，flux架构一定会让你联想到CQRS(Command-Query Responsibility Segregation)、EDA(Event-Driven Architecture)、DDD(Domain-Driven Design)等概念。至于这些概念具体是什么，和flux有什么关系，会在下一篇中介绍。今天我们聊flux与mvc比较之下它的创新之处在哪。

如果你还完全没有接触过React.js也不太要紧。这一篇的内容主要集中于用图解和文字来讲解架构之间的差异，代码部分简单通俗易懂。

### MVC简介

MVC架构讲程序划分为三个角色，从上到下依次为：
- View: 视图，用户数据展示，同时接受用户输入
- Contorller：响应用户的输入，对数据进行操作，
- Model：负责管理程序需要的数据，并且定义了操作数据的行为。

对于一个简单的MVC架构程序来说，其工作流程如下：

![mvc-simple](./images/mvc-vs-flux/mvc-simple.png)

从最右边的View开始，当用户在UI上进行操作之后，用户的操作被转发到了Controller上，Controller根据用户的操作对数据进行更新(准确来说是调用Model层的API)，数据更新之后自然视图View展现的内容也需要进行更新。Model层此时可以向所有关联的视图发出通知，收到通知的视图重新获取最新的数据。注意这最后一步Model与View的交互，大部分现有的MVC框架将其进行了封装，开发人员只要使用数据绑定即可。

如果上面的流程图还过于抽象的话，我们可以看一段MVC项目的代码，比如基于Nodejs的Kraken框架的[Shopping_Cart](https://github.com/lmarkus/Kraken_Example_Shopping_Cart)示例项目中的controller`controllers/index.js`：

```
var Product = require('../models/productModel');

module.exports = function (server) {
    server.get('/', function (req, res) {
        Product.find(function (err, prods) {
            if (err) {
                console.log(err);
            }

            var model =
            {
                products: prods
            };

            res.render('index', model);
        });
    });
};
```

由于这是一个后端框架，用户的操作只能通过url路径体现。当用户访问`/`路径时，首页`index.html`对应的controller，也就是该`controllers/index.js`收到请求，它调用Model层的Product模块的`find`方法请求数据，并将或得到的数据交给`index`模板进行重新渲染，产生的页面返回给用户。

为了和flux做比较，在这里我们要强调几点：

- 通常View和Controller的关系是一一对应的，比如首页index.html有自己的controller`controllers/index.js`，查询页面search.html有自己的controller`controllers/search.js`。从下面这段[angular的路由代码](https://docs.angularjs.org/tutorial/step_07#the-app-module)就是很典型的示例：

```
phonecatApp.config(['$routeProvider',
  	function($routeProvider) {
    	$routeProvider.
      		when('/phones', {
        		templateUrl: 'partials/phone-list.html',
        		controller: 'PhoneListCtrl'
      		}).
      		when('/phones/:phoneId', {
        		templateUrl: 'partials/phone-detail.html',
        		controller: 'PhoneDetailCtrl'
      		}).
      		otherwise({
        		redirectTo: '/phones'
      		});
}]);
```

- controller是有业务逻辑的。虽然在MVC中我们强调"fat model, skinny controller"(业务逻辑应尽量放在Model层，Controller只应该作为View与Model的接口)，但skinny并不代表none，controller中还是有与业务相关的逻辑来决定将如何转发用户的请求，最典型的决定是转发到哪个Model层。

- Model应该被更准确的称为Domain Model(领域模型)，它不代表具体的Class或者Object，也不是单纯的databse。而是一个“层”的概念：数据在Model里得到存储，Model提供方法操作数据(Model的行为)。所以Model代码可以有业务逻辑，甚至可以有数据的存储操作的底层服务代码。

- MVC中的数据流是双向的，模型通知视图数据已经更新，视图直接查询模型中的数据。

### MVC的局限

上小节单组MVC(View、Model、Controller是1:1:1的关系)只是一种理想状态。现实中的程序往往是**多视图**，**多模型**。更严重的是视图与模型之间还可以是**多对多**的关系。也就是说，单个视图的数据可以来自多个模型，单个模型更新是需要通知多个视图，用户在视图上的操作可以对多个模型造成影响。可以想象最致命的后果是，视图与模型之间相互更新的死循环。

这样一来，View与Model与Controller之间的关系就成一团乱麻了，如下两幅图所示：

![mvc-complex](./images/mvc-vs-flux/mvc-complex.png)
![mvc-diagram](./images/mvc-vs-flux/mvc-diagram.png)

如此的混乱会产生很多的问题，比如调试代码。假设在一个复杂的MVC的架构中，有多个controller可以修改model，而开发时model的数据产出并非如你所愿，则你很难判断出是哪个controller出的错，只能使用控制变量法进行调试。

在2014年Facebook举办的F8(Facebook Developer Conference)大会上其中的[Hacker Way: Rethinking Web App Development at Facebook](https://www.youtube.com/watch?v=nYkdrAPrdcw)单元里，Facebook的工程师Jing Chen对于MVC的评价是，MVC非常适合于小型应用，但是当许许多多的Model和与之对应的View被加入到一个系统中，情况就会变得如下图所示：

![flux-react-mvc](./images/mvc-vs-flux/mvc-diagram.png)

需要注意的是，她想表达的意思其实和上述两幅图是相同的，但她在大会上演示的这幅图对MVC的架构描述是有欠缺的。她的这番言论和不准确的图片同时也在[Reddit上也引起了非常多的讨论](https://www.reddit.com/r/programming/comments/25nrb5/facebook_mvc_does_not_scale_use_flux_instead/)，甚至是负面的评价。最后她的回复如下

>Yeah, that was a tricky slide [the one with multiple models and views and bidirectional data flow], partly because there's not a lot of consensus for what MVC is exactly - lots of people have different ideas about what it is. What we're really arguing against is bi-directional data flow, where one change can loop back and have cascading effects.

她承认演示中的图片确实投机取巧了。但其实大部分人对MVC的见解也并不相同，它们真正想表达的是这种双向的数据流架构会产生一定的负面效应。

### Flux

一个简单的flux流程图如下所示：

![flux-simple](./images/mvc-vs-flux/flux-simple.png)

参照上面的图示，我们首先总结一下，flux架构下一共有四类模块角色，按照交互顺序依次是：

- Component/View: 你可以把组件(Component)理解为View与Controller的结合，它既展现数据，同时也处理用户的交互请求。不同于MVC的Controller直接调用模型层业务逻辑处理接口，flux上来自用户的操作或者请求最终会映射为对应的Action，交由Action进行下一步处理。另一点需要注意的是View同时也监听着Store中数据的更改事件，一旦发生更改则重新请求数据。

- Action：描述组件触发的操作，包括名称和数据，比如`{ 'actionType': 'delete', 'data': item}`

- Dispatcher: flux的中央枢纽(central hub)，所有的Action都会交由Dispatcher进行处理。Dispatcher在接收到Action之后，调用Store注册在Action上的回调函数。需要注意与MVC中Controller不同的是，Dispatcher是不包含业务逻辑的，它机械的像一座桥，一个路由器，所以它能被别的程序复用当然也能被别的Dispatcher替换。

- Store：包含程序的数据与业务逻辑。和MVC的Model比较，Store有一些不易被察觉但又非常重要的差异：MVC中的每一个model即对应着一个领域模型；而flux中的一个Store自己并不是一个领域模型，而是可能包含多个模型。**最重要的是**，只有store自己知道如何修改数据，它并不对外直接提供操作数据的接口(但是提供查询数据的接口)，action和dispatcher没法操作store.

一个简单的flux流程我们可以这么描述：用户在View上的操作最终会映射为一类Action，Action传递给Dispatcher，再由Dispatcher执行注册在指定Action上的回调函数。最终完成对Store的操作。如果Store中的数据发生了更改，则触发数据更改的事件，View监听着这些时间，并对这些事件做出反应（比如重新查询数据）。

当有多个Store和View被添加后，复杂的flux流程图如下图所示

![flux-complex](./images/mvc-vs-flux/flux-complex.png)

如果上图还是让你感觉到复杂的话，我们继续抽象flux流程如下：

![flux-complex-abstract](./images/mvc-vs-flux/flux-abstract.png)

由此可见即使是复杂的flux应用，它的数据流和程序的运作过程仍然是清晰可辨的。

### Flux代码

最后这一小节，是用代码来演示flux的简易实现。如果你阅读本文的目的只是想对flux原理稍加了解，则可以略过这小节内容。

#### View

我们从最简单的场景出发，假设页面上只有一个按钮，我们通过这个按钮向store里添加一条数据。这里视图我们通过Reactjs实现：

```
var View = React.createClass({  
    addNewItem: function (event) {
        Dispatcher.dispatch({
          action: 'add_item',
          data: {date: +new Date}        
        });
    },
    render: function(){
        return (
            <button onClick={this.addNewItem}>Add Item</button>
        )
    }
});
```

在按钮的点击事件中我们触发了`add_item`事件。只不过触发事件是直接通过调用`Dispatcher`来实现。

#### Actions

在上面的视图代码中，我们直接调用了Dispatcher的方法。但这样的代码耦合太强了。View其实无需感知Dispatcher，这里我们更是直接把Dispatcher的细节暴露给了View，同时action也没有被抽象出来。

接下来我们把Action抽象出来

```
var Actions = {
  add: function (item) {
      Dispatcher.dispatch({
          action: 'add_item',
          data: item        
      });   
  }
}
```
此时的View也要修改为：

```
var View = React.createClass({  
    addNewItem: function (event) {
        Actions.add({
            date: +new Date
        });
    },
    render: function(){
        return (
            <button onClick={this.addNewItem}>Add Item</button>
        )
    }
});
```

#### Store

Store负责存储并更新数据，它需要监听Dispatcher上触发的action并做出响应：

```
var Store = {
    items: []
}

Dispatcher.register(function(payload) {
    switch(payload.action) {
        case 'add_item':
            // 当事件名为“添加”时，向仓库里添加数据
            Store.items.push(payload.data);
            // 同时触发“数据已更改”的事件
            Store.triggerEvent('change');
            break;
    }
}); 
```

当Store更新完数据之后，它还需要触发一个数据更新的事件，以告知那些关注这些数据的人。如果我们的视图需要在数据更改后时时更新数据，则还需要在Store注册数据更改事件的回调函数

```
var View = React.createClass({
    update: function () {
        // TODO
    }, 
    componentDidMount: function() {  
        Store.bind('change', this.update);
    },  
    addNewItem: function (event) {
        Actions.add({
            date: +new Date
        });
    },
    render: function(){
        return (
            <button onClick={this.addNewItem}>Add Item</button>
        )
    }
});
```

参考文章：

[React.js Tutorial Pt 1: A Comprehensive Guide to Building Apps with React.js](http://tylermcginnis.com/reactjs-tutorial-a-comprehensive-guide-to-building-apps-with-react/)
[React.js Tutorial Pt 3: Architecting React.js Apps with Flux.](http://tylermcginnis.com/reactjs-tutorial-pt-3-architecting-react-js-apps-with-flux/)
[ReactJS For Stupid People](http://blog.andrewray.me/reactjs-for-stupid-people/)
[Flux For Stupid People](http://blog.andrewray.me/flux-for-stupid-people/)
[What the Flux? (On Flux, DDD, and CQRS)](http://jaysoo.ca/2015/02/06/what-the-flux/)
[Facebook: MVC Does Not Scale, Use Flux Instead [Updated]](https://www.infoq.com/news/2014/05/facebook-mvc-flux)
[What is Flux?](http://fluxxor.com/what-is-flux.html)
[Flux vs. MVC (Design Patterns)](https://medium.com/hacking-and-gonzo/flux-vs-mvc-design-patterns-57b28c0f71b7#.2uqupqv13)


