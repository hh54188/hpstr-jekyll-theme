为你的用户找到最佳的文件加载方式是一件麻烦的事。因为有非常多的不同的场景，技术栈，专业术语需要考虑。

在这篇文章里我希望呈现给你所需要的一切，然后你就可以：

- 知道什么样的文件分离策略最适合你的站点和你的用户
- 知道如何实现它

根据 [Webpack 术语表](https://webpack.js.org/glossary/)，有两类文件的分离。这些名词听起来是可以互换的，但实际上不行：

- 打包分离 (Bundle splitting)：为了更好的缓存创建更多、更小的文件（但仍然以每一个文件一个请求的方式进行加载）
- 代码分离 (Code splitting)：动态加载代码，所以用户只需要下载当前他正在浏览的站点的这部分代码

第二种策略听起来更吸引人是不是？事实上许多的文章也假定认为这才是唯一值得将 JavaScript 文件进行小文件拆分的场景。

但是我在这里告诉你第一种策略对许多的站点来说才更有价值，并且应该是你首先为页面做的事

让我们来深入这件事

## 打包分离 (Bundle splitting)

打包分离背后的思想非常简单。如果你有一个体积巨大的文件，并且只改了一行代码，用户仍然需要重新下载整个文件。但是如果你把它分为了两个文件，那么用户只需要下载那个被修改的文件，而浏览器则可以从缓存中加载另一个文件。

值得注意的是因为打包分离与缓存相关，对站点的首次访问者来说没有区别

（我认为太多的性能讨论都是关于站点的首次访问。或许部分原因是因为“第一映像”很重要，另一部分因为这部分性能测量起来简单和讨巧）

当谈论到频繁访问者时，量化性能提升带来的影响会稍有棘手，但是我们必须量化！

这将需要一张表格，所以我们将每一种场景与每一种策略的组合结果都记录下来

这是我在前一段中提到的场景：

- Alice 连续10周每周访问站点一次
- 我们每周更新站点一次
- 我们每周更新“产品列表”页面
- 我们也有一个“产品详情”页面，但是我们目前不需要对它进行更新
- 在第5周的时我们给站点新增了一个 npm 包
- 在第8周时我们更新了现有的一个 npm 包

当然包括我在内的某些人希望场景尽可能的逼真。不要那么做，实际的场景其实无关紧要，我们随后会解释为什么。

## 基线

假设我们的 JavaScript 打包后的总体积时400KB, 并且目前我们以但文件的形式加载它，命名为`main.js`

我们有一个类似如下的 Webpack 配置（我已经移除了无关的配置项）：

```javascript
const path = require('path');

module.exports = {
  entry: path.resolve(__dirname, 'src/index.js'),
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js',
  },
};
```

（对那些刚接触缓知识的人我解释一下：存任何时候我提及`main.js`的时候，我实际上是在说类似于`main.xMePWxHo.js`这种类似于这种包含一堆带有文件内容哈希字符串的文件名。这意味着当你应用中的代码发生更改时就会生成一个新的文件名，这样就能迫使浏览器下载新的文件）

当每周我向站点发布新的变更时，包的`contenthash`就会发生更改。所以每周 Alice 访问我们站点时不得不下载一个全新的 400KB 大小的文件

![](./images/webpack-chunk-split/001.png)

连续十周**也就是 4.12MB**

我们能做的更好

## 分离vender包

让我们把我们的打包文件划分为`main.js`和`vendor.js`

很简单，类似于：

```javascript
const path = require('path');

module.exports = {
  entry: path.resolve(__dirname, 'src/index.js'),
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js',
  },
  optimization: {
    splitChunks: {
      chunks: 'all',
    },
  },
};
```

在你没有告诉它你想如何拆分打包文件的情况下， Webpack 4 在尽它最大的努力把这件事最的最好

这就导致一些正面的声音：“太惊人了，Webpack 做的真不错！”

也带了许多反面的声音：“你对我的打包文件做了什么！”

无论如何，添加`optimization.splitChunks.chunks = 'all'`配置也就是再说“把所有`node_modules`里的东西都放到`vendors~main.js`的文件中去”









