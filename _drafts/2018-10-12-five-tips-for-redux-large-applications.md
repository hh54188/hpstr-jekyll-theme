# 【译文】给构建大型 redux 应用的五个建议

本篇译文的原文在这里：[Five Tips for Working with Redux in Large Applications](https://techblog.appnexus.com/five-tips-for-working-with-redux-in-large-applications-89452af4fdcb)

## 译者序

为什么翻译这篇文章，是因为本文中给出的建议和我在实际项目中的实践不谋而合，更彻底也更优秀。

当项目规模逐渐增大之后，入门文档和教程级别的项目代码的局限性会逐渐显现出来，并且你会遇到在小型应用中不会遇到的问题。更致命的地方在于，如果想要解决这些问题，需要对整个应用的代码做出调整，所谓牵一发而动全身。所以最好是在建立项目之处就有意识的融入最佳实践，有助于预防将来问题的发生

这篇文章并不适合 redux 的初学者，希望你已经开发了少许完整应用，或者至少正在开发你的第一个应用的时候来阅读这篇文章，这样你才更有体会。

相同建议在 Redux 的官方文档或者 React 的官方文档里或多或少肯定都有提及。但是文档太庞大，入口太深以至于把这些内容给淹没了。如果你们没有阅读过它们，至少这一篇也能给你带来提高。

译文中也会加入的个人注解和补充内容；有些不便的翻译，或者翻译后很别扭，或者大家公认的技术词汇的地方仍然保持原文。下面正式开始

## 正文

Redux 一个用于管理应用状态的出色工具。它的单向数据流和 immmutable state 特色让我们更容易追踪状态的变更。每一个状态的变更都是由被调度的 action 导致 reducer 函数返回新的状态引起的。我们站点上的许多使用 Redux 构建的用户界面都需要处理大量的数据和复杂的交互，因为用户需要通过这些界面管理他们的广告或者在平台上更新库存信息。在开发这些界面的过程中，我们掌握了一些规则和窍门有助于我们让 Redux 更易于管理。接下来要讨论的几个要点对那些使用 Redux 开发大型数据集成类型应用的同学们有所帮助

- 使用索引和选择器用于排序和访问数据
- 把数据对象、编辑状态和其他的UI状态隔离开
- 判断是否在单应用的多个视图间共享状态
- 在状态间重用 reducer
- 将组件连接至 Redux 状态的最佳实践

## 使用索引（index）存储数据，使用选择器（selector）访问数据

选择正确的数据结构对应用的组织和性能至关重要。使用索引存储来自API的可序列化数据会带来很多好处。索引指的是我们需要进行存储的对象里的对象id，而值则是对象本身。这个模式类似于使用哈希来存储数据，可以节省查找的时间。对于精通 Redux 的人来说这可能不足为奇。事实上 Redux 的作者，Dan Abramob 在他的 [Redux 教程](https://egghead.io/lessons/javascript-redux-persisting-the-state-to-the-local-storage)里也推荐这种数据结构

想象你从 REST 接口里请求到了一个列表数据，比如来自`/users`服务。我们假设决定简单的把这个纯数组存储在我们的状态中，和接口返回里的一模一样。那么当我们需要从对象里获取某个具体的用户信息时会发生什么？我们需要遍历状态状态里的所有用户。如果用户数量太多，这会是一个费时的操作。又比如我们想要追踪用户的子集，比如选中的用户或者非选中的用户又该怎么办？我们要么把用户存储为两个独立隔离的数组，要么追踪数组里被选中和非选中的用户索引

取而代之的我们决定重构我们的代码来使用索引存储数据。在 reducer 中我们应该像这样存储数据：

```javascript
{
 "usersById": {
    123: {
      id: 123,
      name: "Jane Doe",
      email: "jdoe@example.com",
      phone: "555-555-5555",
      ...
    },
    ...
  }
}
```
但这样的数据结构又是如何帮助我们解决这些问题的呢？如果我们需要查找一个特定的用户对象，我们只需要简单的像这样访问即可：`const user = state.usersById[userId]`. 这个方法不需要遍历整个数组，节省了我们的时间并且简化了检索代码

此时你或许对如何将这种数据结构的数据渲染为什么一个简单的用户列表感到疑惑。要完成这项工作，我们需要一个选择器，即一个传入状态然后返回数据的函数。一个获取状态中所有用户的简单选择器的例子是：

```javascript
const getUsers = ({ usersById }) => {
  return Object.keys(usersById).map((id) => usersById[id]);
}
```
在我们的视图代码中，我们选择器函数用户获取用户列表。然后我们遍历这些用户来产生我们的视图。我们可以编写另一个函数用于从状态中获取被选中的用户

```javascript
const getSelectedUsers = ({ selectedUserIds, usersById }) => {
  return selectedUserIds.map((id) => usersById[id]);
}
```
选择器模式同样提高了我们代码的可维护性。想象或许一段时间后我们需要改变状态的结构（shape）。如果没有选择器的话，我们需要更新所有的视图代码来响应状态结构的修改。随着视图组件的增加，更改状态结构的负担也会剧烈的增长。为了避免这个问题，在视图中我们会使用选择器来访问状态，如果底层的状态结构发生了改变，我们只需要更新选择器来保证使用正确的方式来访问状态。所有的消费方的组件依然会得到它们需要的数组而不用发生更改。基于所有这些原因，大型的 Redux 应用会从索引和选择器的存储模式中受益

## 将标准状态与视图和编辑状态区分开


