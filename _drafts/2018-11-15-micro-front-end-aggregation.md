# 从美团这篇文章聊聊微前端的聚合问题

最近我打算在我的面试题库里加一道题，用于考验候选人的应用的设计能力，这个问题也来源于最近经历的真实的业务问题：

> 我目前所在的技术中台部门为公司的业务部门开发了非常多的工具应用，比如数据分析、比如A/B测试、比如部署发布平台等等。它们都是基于 React 框架，然后辅佐以不同的状态管理框架进行开发，比如 redux，mobx，又或者 dva。这些应用都是由不同的前端团队维护开发，所以不难想象大家其实重叠的开发了相同的功能或者相同的组件，比如登陆验证（都是基于公司级别的 OAuth ），比如错误处理，又比如发送消息给用户等等。
> 因为分散在不同的域名但其实又联系紧密，不便于使用，所以我们打算把它们聚合在同一个门户（站点）下，顶部显示一条公共的导航栏，下方是当前具体的应用。通过导航栏的菜单在当前页面下切换不同的应用。让用户有一种使用单一应用的感觉。
> 如何来设计这个聚合方案？

如果大家听说过“微服务（Microservices）”的概念的话就不难理解“微前端（Micro Frontends）”。和后端应用类似，当一个前端应用变得异常庞大以后，它会变得难以维护，同时也会变得不稳定。将大的应用拆分为小的应用能够让每个专业团队专心负责自己的功能，更易于测试、部署以及发布。

但是这样的拆分有很多，最常见的，是将单个应用拆分为多个独立的应用，通过导航栏和动态加载来实现无缝的切换，这样的 app 甚至可以采用不同的技术栈进行构建:

![](./images/micro-front-end/multi-app.png)

单个页面上的模块也可以拆分为不同的微前端由不同的团队使用不同的技术栈进行开发：

![](./images/micro-front-end/three-teams.png)

这是两个极端。其他场景包括但不限于

- 把第三方的SaaS应用进行集成，
- 把第三方私服应用进行集成（比如在公司内部部署的 gitlab）
- 在相同技术栈下chu以上各种情况

同理有时候我们也需要进行反向（）的操作，比如在开头的例子中，在已有多个应用的情况下，需要将它们聚合为一个单应用。

可以想象正向的自顶向下的拆分远比反向的聚合简单，因为在开发之初你们就能遇见功能，约定接口，统一技术栈，提取公共组件等等；而反向聚合下一切都是未知的，任何困难都有可能发生，只能见招拆招

说到底，微前端的聚合问题其实是非常复杂的，复杂之处在于细分的场景太多，没法给出一个大一统的解决方案，所以在本文中要处理的问题也仅限于题目中所描述的那样。但即便如此，本文中所描述的思路，考虑到的问题，或许你在未来处理相关问题是依然能够拿来参考。

也许阅读到这里你可以暂停一会，你可以拿起笔和纸用十到十五分钟的时间来思考如何解决这个问题。在面试一个人的时候，他给出的结果并不重要，重要的是它解决问题的思路以及考虑问题是否周全。一个高手和菜鸟可能会给出同样的答案，但高手是深思熟虑的结果，菜鸟则是凭直觉撞到了枪口上。

在解决这个问题的时候，同事向我推荐了美团技术博客的一篇关于微前端的文章[《用微前端的方式搭建类单页应用》](https://tech.meituan.com/fe_tiny_spa.html)。这篇文章为我们提供了一类解决问题的方案，这个方案刚好可以作为我们解决这类问题的一个线索。但是在方案中仍然有值得商榷的地方。文章接下来的内容，就是聊聊这些值得商榷的地方，重点谈文章中的两点：**注册机制**和**命名空间**。

最后，指出这些不足并没有贬低的意思，我也没法给出一个明确的、更高明的解决办法，而是旨在提供探讨更多的可能性。在正式开始最好先阅读完毕美团的这篇文章，并且与之前你个人的思考结果进行对比。也许你会迸发出一些和我们不一样的想法

不过最后还是要吐槽一下，美团这篇文章写得不好，看得我云里雾里的，最后还是没怎么看懂，至少没有解决我认为的几个关键问题。

## 注册机制

美团的需求和我们的需求是一致的，用原文中的话说是

>HR系统转变成只有一个域名和一套展示风格的系统

在没有更多额外信息的情况下，我默认认为不同系统之间不需要通信和交互，每个系统都是独立的应用。但是仍然有逻辑交叉，比如用户登陆机制、全局异常处理等等。

美团的做法是新建一个公共级别的项目，叫做 Portal（“传送门”？），所有的子项目将自己的信息需要向这个 Portal 进行注册，包括路由、包括命名空间。之后所有的项目引入这个功能的组件。那么在之后每个项目上线时，通过路由（导航栏？）动态的加载子项目资源（脚本/样式）来动态的加载子项目

通常在做反向聚合的工作时，除了要新建类似于上面的容器/入口级别的项目，还需要对原项目进行修改，对原项目修改是痛苦的，因为需要向前和向后的兼容。如果是不同团队维护的项目，你还需要推动“人”去做这方面的修改。所以最理想的状态是“非侵入性”的改造，即原项目是无感知的。这似乎比较难，当然退而求其次，我们的目标是尽可能的把改动的代价降到最小。

在美团的方案中，他们希望把公共类库交给 Portal 去维护和加载而又不侵入式的改造项目，于是决定在构建阶段替换掉子项目的`require('react')`方法，改为`window.app.require('react')`，即 Portal 的私有 `require`方法。这样看似就能减少子项目的关心项，同时对公共类库进行统一管理；

**但是我们真的需要公共类库管理吗？**

我们可以理解他们为什么要做高公公类库管理，一方面避免资源的重复加载，例如 `react`, `react-dom`, `lodash` 的类库每个项目都要使用到，另一方面能保证所有项目用到的内部组件库发布之后所有项目使用到的都是统一最新的

但在实际情况下，子项目是来自不同时期的不同团队做的，所以哪怕是基本的类库都会出现版本不统一的地方（你可能会有疑问：为什么他们不及时更新呢？很多原因，比如功能够用便不再开发了，比如使用到的其他类库只兼容到这个版本）

所以说即便你想进行对类库的统一管理，务必还是要对其他的项目进行入侵式的修改，兼容、测试的工作依然不能少。

那我们依然可以退而求其次，公用某些版本的组件。那么当子项目注册时，需要向 Portal 注册它依赖的类库和对应的版本。这又会产生另一个问题，你如何在单页面应用中管理多个版本的相同类库？例如项目 A 依赖`react@15`，项目 B 依赖`react@16`，当用户从 A 切换至 B 又切换至 A 时，`react@15`需要重新加载吗？很明显不需要，应该把类库缓存起来。更极端的，我们不应该依赖 HTTP 缓存，而是应该把已经加载的类库缓存到内存中，那么这你还需要解决内存中相同类库命名空间冲突问题。

美团方案中另一个很有意思的现象地方时，貌似所有的子应用都是使用 Redux 框架编写的，因为在向 Portal 注册时还需要注册 reducers。

## 命名空间





## 参考资料

- [用微前端的方式搭建类单页应用](https://tech.meituan.com/fe_tiny_spa.html)
- [Micro frontends—a microservice approach to front-end web development](https://medium.com/@tomsoderlund/micro-frontends-a-microservice-approach-to-front-end-web-development-f325ebdadc16)
- [Micro Frontends](https://micro-frontends.org/)